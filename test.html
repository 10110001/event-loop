<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="shell.css">
    <title>event-loop test</title>
</head>
<body style="height: 2000px;">

<button id="testButton" onclick="startTest()" style="font-size:xx-large">Redo test</script>
<div style="overflow:hidden">
    <div id="slider"></div>
</div>
<div id="mutator"></div>
<script>
'use strict';

var RESULTS = [];

function addResultToDocument(msg, type) {
    let el = document.createElement('div');
    if (type)
        el.classList.add(type);
    el.classList.add('result');
    el.innerText = msg;
    document.body.appendChild(el);
}

function reportError(msg) {
    addResultToDocument(msg, 'error');
}

function log(...args) {
    let line = args.join(' ');
    console.log(Math.round(performance.now()*100)/100 + ' ' + line);
    RESULTS.push(line);
}

function assertOrder(r1, r2, msg) {
    var i1 = RESULTS.indexOf(r1);
    var i2 = RESULTS.indexOf(r2);
    if (i1 == -1)
        reportError(r1 + " not found");
    if (i2 == -1)
        reportError(r2 + " not found");
    if (i2 <= i1)
        reportError('"' + r1 + '" before "' + r2 + '": ' + msg);
}

function endTest() {
// Promise/rAF asserts
    assertOrder("script end", "promise A", "promise handlers executed after script");
    assertOrder("promise A", "promise B", "promise handlers in order");

    assertOrder("rAF A", "rAF B", "rAF in order");

    assertOrder("promise A", "rAF A", "rAF after promise handlers");

    assertOrder("promise A", "timeout A", "timeout after promise handlers");
    assertOrder("rAF A promise", "rAF B", "promise handler immediately after rAF");

    let p1 = RESULTS.indexOf('promise B'), p0 = RESULTS.indexOf('promise A');
    if ((p1 - p0) > 2)
        reportError("Microtasks queue not executed all at once, distance is " + (p1 - p0) );

    assertOrder("promise A", "mutate", "mutate microtask after promise A")
    assertOrder("mutate", "promise B", "mutate happens before promise B resolves");

// render events
    assertOrder("matchMedia", "resize", "matchMedia before resize");
    assertOrder("resize", "scroll", "resize before scroll");
    assertOrder("scroll", "rAF A", "scroll before rAF");
    assertOrder("animationstart", "rAF A", "css animation starts before rAF");
    assertOrder("resize", "animationstart", "css animation starts before rAF");

  //  addResultToDocument("rAF and timeout order is unspecified", "warn");
    if (!document.querySelector('.error'))
        addResultToDocument('tests passed');

    document.querySelector('#slider').classList.remove('animate');
    addResultToDocument('output in console');
}


function startTest() {
    RESULTS = [];
    log("script start");
    var oldResults = document.querySelectorAll('.result');
    for (var i=0; i<oldResults.length; i++)
        oldResults[i].parentNode.removeChild(oldResults[i]);
    // for (let el of document.querySelectorAll('.result'))
    //     el.parentNode.removeChild(el);

// rAF

    window.requestAnimationFrame( _ => {
        log("rAF A");
        new Promise( (fulfill, reject) => {
            fulfill();
        })
        .then(_ => {
            log("rAF A promise");
        });
    });

    window.requestAnimationFrame( _ => {
        log("rAF B");
    });

// timeouts

    window.setTimeout(_ => { log('timeout A');}, 0);

    window.setTimeout(_ => { log('timeout B');}, 0);

// Promises
    let p = new Promise( (fulfill, reject) => {
        fulfill();
        // log("promise A fulfill");
    })
    .then(_ => {
        log("promise A");
        return new Promise( fulfill => {
            fulfill();
        });
    })
    .then(_ => {
        log("promise B");
    });

// CSS Animation
    document.querySelector('#slider').classList.remove('animate');
    document.querySelector('#slider').classList.add('animate');

// Scrolling

    window.scrollBy(0,10);

// Resize
    window.parent.document.querySelector('iframe').width = "450px";

// Mutations
    document.querySelector('#mutator').appendChild(
        document.createElement('div')
    );

// Test end
    window.setTimeout(_ => { endTest(); }, 500);

    log("script end");

}

// Listeners

window.addEventListener('resize', _ => {
    log('resize');
});

window.addEventListener('scroll', _ => {
    log('scroll');
});

window.matchMedia("(min-width: 400px)").addListener( _ => {
    log('matchMedia');
});

document.querySelector('#slider').addEventListener('animationstart', _=> {
    log('animationstart');
});

let mutObs = new MutationObserver( entries => {
    log('mutate');
});

mutObs.observe(document.querySelector('#mutator'),
    { childList: true, attributes: true });

window.addEventListener('message', ev => {
    console.log('message', ev.data);
    switch(ev.data) {
        case 'startTest':
            window.requestAnimationFrame(startTest);
            break;
        default:
            break;
    }
});

</script>
</body>
</html>
